module Exercise8 where

-- Defining all the boys
data Boy = Matthew | Peter | Jack | Arnold | Carl
    deriving (Eq,Show)
    
-- Array of all boys
boys :: [Boy]
boys = [Matthew, Peter, Jack, Arnold, Carl]

-- Defining the accusations based on the provided criteria
accuses ::  Boy -> Boy -> Bool
Peter `accuses` Matthew = True
Peter `accuses` Jack = True
Matthew `accuses` Matthew = False
Matthew `accuses` Carl = False
_ `accuses` _ = False


-- Pattern matches which boys accused who
accusers ::  Boy -> [Boy]
accusers Matthew = [Peter, Jack, Arnold]
accusers Peter = [Jack]
accusers Jack = [Peter]
accusers Arnold = [Carl]
accusers Carl = []

-- Pattern based statements to the statements provided in the problem
-- These are used to determine any contradictions that the boys made
statement :: Boy -> Bool
statement Matthew = not (Matthew `accuses` Carl || Matthew `accuses` Matthew) --DeMorgan's law
statement Peter = Peter `accuses` Matthew || Peter `accuses` Jack
statement Jack = not (statement Matthew) && not (statement Peter)
statement Arnold = statement Matthew /= statement Peter
statement Carl = not (statement Arnold)

-- Returns a tuple with the boy and his statement 
statementWBoy :: Boy -> (Boy, Bool)
statementWBoy b = (b, statement b)

-- Trying to understand the problem:
--      Assuming that the statements provided by Jack and Arnold
--      have contradictions within, we can deduct that their statements
--      are false and hence Jack and Arnold prove to be not honest.

-- Returns an array of tuples with the boys who have said the truth
isHonest :: [(a, Bool)] -> [a] -> [a]
isHonest [] outputArray = outputArray 
isHonest ((boy, True):xs) outputArray = isHonest xs (boy : outputArray)
isHonest ((_, False):xs)  outputArray = isHonest xs outputArray 

-- Returns all boys who are honest 
honest ::  [Boy]
honest = isHonest tuplesArr []
    where tuplesArr = map statementWBoy boys 

-- Returns an array of liars by removing the honest people from the total boys array
liars :: [Boy]
liars = removeSet honest boys

-- Utility function to remove a subset from an array
-- https://stackoverflow.com/questions/43186151/removing-a-subset-from-a-set -> Made it a more readable as it was using currying
removeSet :: (Foldable t, Eq a) => t a -> [a] -> [a]
removeSet subset fullSet  = filter (not.(`elem`subset)) fullSet

-- Utility function to pair an honest boy with a liar
-- This is used to deduce which boy is the thief
honestLiarTupleArr :: [(Boy, Boy)]
honestLiarTupleArr = [ (x,y) | x<- honest, y<-liars ]

-- The function which determins if a boy is the thief
--  Recursively iterates over all the tuples generated using honestLiarTupleArr (these tuples contain (InnocentBoy, Liar)).
--  Checks all accusations that the honest boy made about the liar
--  Appends the thief to an array of results if an accustation is found to be true
accussWithBoy :: [(Boy, Boy)] -> [Boy] -> [Boy]
accussWithBoy [] listOfGuilty = listOfGuilty
accussWithBoy ((honestB, lyingB):xs) listOfGuilty
    | honestB `accuses` lyingB = accussWithBoy xs (lyingB : listOfGuilty)
    | otherwise = accussWithBoy xs listOfGuilty

-- Final function which finds the thief, uses the accussWithBoy function with the array generated by honestLiarTupleArr with a initial output array of []
guilty :: [Boy]
guilty = accussWithBoy honestLiarTupleArr []

-- Team thinking space:
--      We know that the honest boys -> [Carl,Peter,Matthew]
--      Therefore the liars are -> [Arnold, Jack]
--      By checking the statements we see that Jack accuses Matthew's and Peter's statement, but they are telling the truth
--          Matthews statement says that it was neither Matthew nor Carl
--          Peters statement says it was either Matthew or Jack, by the premise that Matthew's statement is honest, Jack is the thief

-- Time Spent: 6+ hours (without individual hours, only together)