module Exercise3 where
import           Data.Bool                      ( bool )
import           Data.List
import           Exercise1
import           Exercise2
import           MultiplicationTable
import           Mutation
import           Test.QuickCheck

-- Time spend: 300 minutes --


-- Documentation of the approach:
--  Integer -> [([Integer] -> Integer -> Bool)] -> (Integer -> [Integer])
    -- num mutants - list of properties - function under test (multiplication)

-- MATRIX       Mutator 1   Mutator 2   Mutator 3
-- Property 1   0           1           1
-- Property 2   1           0           1
-- Implementation

-- Method created to identify combinations of properties for which,
-- provided a set number of mutators (ref. to mutatorList),
-- in conjunction the properties kill mutants for ALL mutators.
minimalPropertySubsetResult :: Gen [([Char], Bool)]
minimalPropertySubsetResult = do
    let propsList = -- List of properties being tested (stored in tuple to retain named of properties)
            [ ("prop_firstElementIsInput", prop_firstElementIsInput)
            , ("prop_linear"             , prop_linear)
            , ("prop_moduloIsZero"       , prop_moduloIsZero)
            , ( "prop_sumIsTriangleNumberTimesInput"
              , prop_sumIsTriangleNumberTimesInput
              )
            , ("prop_tenElements", prop_tenElements)
            ]
    -- List of mutators being under test for all property set combinations
    let mutatorList =
            [ addElements
            , removeElements
            , multiplyByAListOfInts
            , multiplyElements
            , changeOrder
            , addForModulus
            , totallyRandom
            , changeRandomElement
            ]
    -- creates a matrix, where for each property, all mutators are tested. The intersection
    -- between property and mutator is False if for all mutants generated with said mutator,
    -- property sucessfully kills mutants, otherwise the intersection's value is True.
    matrix <- createPropertyByMutatorMatrix 1
                                            mutatorList
                                            propsList
                                            multiplicationTable
    --let lengthMatrix = length matrix
    -- All combinations of matrix rows are generated using subsequences
    let subsequencesMatrix = subsequences matrix
    -- checking that sets returned are those which:
    -- a. Combination of Properties returns true i.e. together these properties kill all mutants
    --    with the mutators specified.
    -- b. Filters out empty property lists generated by the checker's base condition
    let minimumPropertySets = filter
            (\(name, boolRes) -> boolRes && name /= "")
            (map checker subsequencesMatrix)
    return minimumPropertySets

createPropertyByMutatorMatrix
    :: Integer
    -> [[Integer] -> Gen [Integer]]
    -> [(String, [Integer] -> Integer -> Bool)]
    -> (Integer -> [Integer])
    -> Gen [(String, [Bool])]
createPropertyByMutatorMatrix _          _           []          _ = return []
createPropertyByMutatorMatrix numMutants listMutants (p : props) f = do
    mutants  <- mutantsPropertyAxis numMutants listMutants p f
    -- Recursively generating, row by row, all mutator survival results (boolean) per property
    propAxis <- createPropertyByMutatorMatrix numMutants listMutants props f
    return (mutants : propAxis)


-- generating single row of property-mutator matrix (row for one prop)
mutantsPropertyAxis
    :: Integer
    -> [[Integer] -> Gen [Integer]]
    -> (String, [Integer] -> Integer -> Bool)
    -> (Integer -> [Integer])
    -> Gen (String, [Bool])
-- base condition after traversing all mutators
mutantsPropertyAxis _          []       (name, property) _ = return (name, [])
mutantsPropertyAxis numMutants (x : xs) (name, property) f = do
    survivorsCount <- countSurvivors numMutants x [property] f
    -- if there are any survivors created by mutator when tested by property, then we set
    -- bool value to true (i.e. property has survivors when using mutator X to create mutants)
    let boolCountCheck = survivorsCount > 0
    (name, tailListOfInt) <- mutantsPropertyAxis numMutants
                                                 xs
                                                 (name, property)
                                                 f
    return (name, boolCountCheck : tailListOfInt)

-- Checks recursively, for all subsequences of property sets, if combination of properties kills
-- all mutants for mutator list specified.
checker :: [(String, [Bool])] -> (String, Bool)
checker [] = ("", True)
-- when more than 2 properties belong within the subsequence checked
checker ((nameX, x) : (nameY, y) : xs)
    | length x == 1 = (nameX, all (== False) x)
    | otherwise     = (setOfPropName, all (== False) processed && boolVal) -- recursive verification that all mutants are killed
  where
    (_, boolVal)  = checker ((setOfPropName, processed) : xs)
    setOfPropName = nameX ++ ", " ++ nameY -- syntactic - to display combination of property names in result
    -- we compare prop A with B and confirm if all intersections,
    -- when ANDed together, are false i.e. all mutants are killed
    processed     = map (\(left, right) -> left && right) zipped
    zipped        = zip x y
-- when 2 properties remain in the subsequence checked
checker ((nameX, x) : y) | null y    = ("", True)
                         | otherwise = (setOfPropName, all (== False) processed)
  where
    setOfPropName    = nameX ++ ", " ++ nameY
    processed        = map (\(left, right) -> left && right) zipped
    zipped           = zip x headOfY
    (nameY, headOfY) = head y


-- CODE NO LONGER USED:

--    return (length firstP, length secondP, length thirdP, length fourthP, length fifthP)
-- combinationCheck (x:xs) index = do

-- check (x:xs) counter =
--     !!

-- minimalSubsets:: Integer -> [([Integer] -> Integer -> Bool)] -> (Integer -> [Integer]) -> Integer
-- minimalSubsets numMutants props = goThroughAllPermutations 0 combinationOfProperties numMutants
-- where combinationOfProperties = permutations props

-- -- minimum amount of
-- goThroughAllPermutations:: Integer -> [([Integer] -> Integer -> Bool)] -> Integer (Integer -> [Integer]) -> [Integer] -> [Integer]
-- goThroughAllPermutations _ [] _ _ _ = result
-- goThroughAllPermutations min (x:xs) numMutants f
-- | min > survivors = goThroughAllPermutations survivors xs numMutants f x
-- |
-- | otherwise = goThroughAllPermutations min xs numMutants f
-- where survivors = count_survivors(numMutants x f)
